Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOUBLEEQUAL
    GTE
    LTE
    THEN_K

Grammar

Rule 0     S' -> PROGRAM
Rule 1     PROGRAM -> PROGRAM_K ID neural_program_id SEMICOLON BLOCK
Rule 2     neural_program_id -> EMPTY
Rule 3     BLOCK -> VAR_BLOCK PROC_BLOCK PRINCIPAL_BLOCK
Rule 4     VAR_BLOCK -> VARS_K BLOCKSTART VAR_DECL BLOCKEND
Rule 5     VAR_DECL -> TYPE COLON VAR_LIST SEMICOLON VAR_DECL_R
Rule 6     VAR_DECL_R -> VAR_DECL
Rule 7     VAR_DECL_R -> EMPTY
Rule 8     VAR_LIST -> ID VAR_LIST2
Rule 9     VAR_LIST2 -> COMMA ID VAR_LIST2
Rule 10    VAR_LIST2 -> EMPTY
Rule 11    TYPE -> INT_K NEURAL_TYPE
Rule 12    TYPE -> FLOAT_K NEURAL_TYPE
Rule 13    TYPE -> STRING_K NEURAL_TYPE
Rule 14    NEURAL_TYPE -> EMPTY
Rule 15    PROC_BLOCK -> PROC_DECL
Rule 16    PROC_DECL -> PROC_DECL_RETURN
Rule 17    PROC_DECL -> PROC_DECL_VOID
Rule 18    PROC_DECL -> EMPTY
Rule 19    PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
Rule 20    neural_proc_void_id -> EMPTY
Rule 21    PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
Rule 22    neural_proc_return_id -> EMPTY
Rule 23    neural_param_decl -> EMPTY
Rule 24    PARAM_DECL -> TYPE ID neuro PARAM_DECL_R
Rule 25    PARAM_DECL -> EMPTY
Rule 26    neuro -> EMPTY
Rule 27    PARAM_DECL_R -> COMMA PARAM_DECL
Rule 28    PARAM_DECL_R -> EMPTY
Rule 29    PROC_BODY -> STATEMENT PROC_BODY_R
Rule 30    PROC_BODY_R -> PROC_BODY
Rule 31    PROC_BODY_R -> EMPTY
Rule 32    STATEMENT -> ASSIGN SEMICOLON
Rule 33    STATEMENT -> FUNC_CALL SEMICOLON
Rule 34    STATEMENT -> READ SEMICOLON
Rule 35    STATEMENT -> WRITE SEMICOLON
Rule 36    STATEMENT -> FLOW
Rule 37    FLOW -> DECISION
Rule 38    FLOW -> LOOP
Rule 39    LOOP -> WHILE_LOOP
Rule 40    LOOP -> FOR_LOOP
Rule 41    WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
Rule 42    FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND
Rule 43    DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
Rule 44    DECISION_ALT -> ELSE_K DECISION
Rule 45    DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND
Rule 46    DECISION_ALT -> EMPTY
Rule 47    STATEMENT_R -> STATEMENT STATEMENT_R
Rule 48    STATEMENT_R -> EMPTY
Rule 49    ASSIGN -> VAR EQUALS H_EXPRESSION
Rule 50    VAR -> ID
Rule 51    VAR -> ARRAY
Rule 52    ARRAY -> ID LBRACE INT RBRACE
Rule 53    FUNC_CALL -> ID LPAREN ARG_LIST RPAREN
Rule 54    ARG_LIST -> VAR ARG_LIST_R
Rule 55    ARG_LIST -> CONSTANT ARG_LIST_R
Rule 56    ARG_LIST -> ARG_LIST_R
Rule 57    ARG_LIST_R -> COMMA ARG_LIST
Rule 58    ARG_LIST_R -> EMPTY
Rule 59    CONSTANT -> INT
Rule 60    CONSTANT -> FLOAT
Rule 61    CONSTANT -> STRING
Rule 62    READ -> READ_K ID_LIST
Rule 63    ID_LIST -> ID ID_LIST_R
Rule 64    ID_LIST_R -> COMMA ID_LIST
Rule 65    ID_LIST_R -> EMPTY
Rule 66    WRITE -> WRITE_K WRITE_LIST
Rule 67    WRITE_LIST -> H_EXPRESSION WRITE_LIST_R
Rule 68    WRITE_LIST_R -> COMMA H_EXPRESSION
Rule 69    WRITE_LIST_R -> EMPTY
Rule 70    RETURN -> RETURN_K LPAREN H_EXPRESSION RPAREN SEMICOLON
Rule 71    EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R
Rule 72    NEURAL_EXPRESSION -> EMPTY
Rule 73    EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION
Rule 74    EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION
Rule 75    EXPRESSION_R -> EMPTY
Rule 76    NEURAL_PLUS -> EMPTY
Rule 77    NEURAL_MINUS -> EMPTY
Rule 78    TERM -> FACTOR NEURAL_TERM TERM_R
Rule 79    NEURAL_TERM -> EMPTY
Rule 80    TERM_R -> TIMES NEURAL_TIMES TERM
Rule 81    TERM_R -> DIVIDE NEURAL_DIVIDE TERM
Rule 82    TERM_R -> EMPTY
Rule 83    NEURAL_TIMES -> EMPTY
Rule 84    NEURAL_DIVIDE -> EMPTY
Rule 85    FACTOR -> ID NEURAL_ID
Rule 86    FACTOR -> CONSTANT
Rule 87    FACTOR -> LPAREN EXPRESSION RPAREN
Rule 88    NEURAL_ID -> EMPTY
Rule 89    S_EXPRESSION -> EXPRESSION
Rule 90    S_EXPRESSION -> EXPRESSION GT EXPRESSION
Rule 91    S_EXPRESSION -> EXPRESSION LT EXPRESSION
Rule 92    H_EXPRESSION -> S_EXPRESSION H_EXPRESSION_R
Rule 93    H_EXPRESSION_R -> OR H_EXPRESSION
Rule 94    H_EXPRESSION_R -> AND H_EXPRESSION
Rule 95    H_EXPRESSION_R -> EMPTY
Rule 96    PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND
Rule 97    PRINCIPAL_BODY -> STATEMENT PRINCIPAL_BODY_R
Rule 98    PRINCIPAL_BODY_R -> PRINCIPAL_BODY
Rule 99    PRINCIPAL_BODY_R -> EMPTY
Rule 100   EMPTY -> <empty>

Terminals, with rules where they appear

AND                  : 94
BLOCKEND             : 4 19 21 41 42 43 45 96
BLOCKSTART           : 4 19 21 41 42 43 45 96
COLON                : 5
COMMA                : 9 27 57 64 68
COMMENT              : 
DIVIDE               : 81
DOUBLEEQUAL          : 
DO_K                 : 42
ELSE_K               : 44
EQUALS               : 42 49
FLOAT                : 60
FLOAT_K              : 12
FOR_K                : 42
FUNCTION_K           : 19 21
GT                   : 90
GTE                  : 
ID                   : 1 8 9 19 21 24 42 50 52 53 63 85
IF_K                 : 43
INT                  : 42 42 52 59
INT_K                : 11
LBRACE               : 52
LPAREN               : 19 21 41 43 53 70 87 96
LT                   : 91
LTE                  : 
MAIN_K               : 96
MINUS                : 74
OR                   : 93
PLUS                 : 73
PROGRAM_K            : 1
RBRACE               : 52
READ_K               : 62
RETURN_K             : 70
RPAREN               : 19 21 41 43 53 70 87 96
SEMICOLON            : 1 5 32 33 34 35 70
STRING               : 61
STRING_K             : 13
THEN_K               : 
TIMES                : 80
TO_K                 : 42
VARS_K               : 4
VOID_K               : 19
WHILE_K              : 41
WRITE_K              : 66
error                : 

Nonterminals, with rules where they appear

ARG_LIST             : 53 57
ARG_LIST_R           : 54 55 56
ARRAY                : 51
ASSIGN               : 32
BLOCK                : 1
CONSTANT             : 55 86
DECISION             : 37 44
DECISION_ALT         : 43
EMPTY                : 2 7 10 14 18 20 22 23 25 26 28 31 46 48 58 65 69 72 75 76 77 79 82 83 84 88 95 99
EXPRESSION           : 73 74 87 89 90 90 91 91
EXPRESSION_R         : 71
FACTOR               : 78
FLOW                 : 36
FOR_LOOP             : 40
FUNC_CALL            : 33
H_EXPRESSION         : 41 43 49 67 68 70 93 94
H_EXPRESSION_R       : 92
ID_LIST              : 62 64
ID_LIST_R            : 63
LOOP                 : 38
NEURAL_DIVIDE        : 81
NEURAL_EXPRESSION    : 71
NEURAL_ID            : 85
NEURAL_MINUS         : 74
NEURAL_PLUS          : 73
NEURAL_TERM          : 78
NEURAL_TIMES         : 80
NEURAL_TYPE          : 11 12 13
PARAM_DECL           : 19 21 27
PARAM_DECL_R         : 24
PRINCIPAL_BLOCK      : 3
PRINCIPAL_BODY       : 96 98
PRINCIPAL_BODY_R     : 97
PROC_BLOCK           : 3
PROC_BODY            : 19 21 30
PROC_BODY_R          : 29
PROC_DECL            : 15 19 21
PROC_DECL_RETURN     : 16
PROC_DECL_VOID       : 17
PROGRAM              : 0
READ                 : 34
RETURN               : 21
STATEMENT            : 29 47 97
STATEMENT_R          : 41 42 43 45 47
S_EXPRESSION         : 92
TERM                 : 71 80 81
TERM_R               : 78
TYPE                 : 5 21 24
VAR                  : 49 54
VAR_BLOCK            : 3
VAR_DECL             : 4 6
VAR_DECL_R           : 5
VAR_LIST             : 5
VAR_LIST2            : 8 9
WHILE_LOOP           : 39
WRITE                : 35
WRITE_LIST           : 66
WRITE_LIST_R         : 67
neural_param_decl    : 19 21
neural_proc_return_id : 21
neural_proc_void_id  : 19
neural_program_id    : 1
neuro                : 24

Parsing method: LALR

state 0

    (0) S' -> . PROGRAM
    (1) PROGRAM -> . PROGRAM_K ID neural_program_id SEMICOLON BLOCK

    PROGRAM_K       shift and go to state 2

    PROGRAM                        shift and go to state 1

state 1

    (0) S' -> PROGRAM .



state 2

    (1) PROGRAM -> PROGRAM_K . ID neural_program_id SEMICOLON BLOCK

    ID              shift and go to state 3


state 3

    (1) PROGRAM -> PROGRAM_K ID . neural_program_id SEMICOLON BLOCK
    (2) neural_program_id -> . EMPTY
    (100) EMPTY -> .

    SEMICOLON       reduce using rule 100 (EMPTY -> .)

    neural_program_id              shift and go to state 4
    EMPTY                          shift and go to state 5

state 4

    (1) PROGRAM -> PROGRAM_K ID neural_program_id . SEMICOLON BLOCK

    SEMICOLON       shift and go to state 6


state 5

    (2) neural_program_id -> EMPTY .

    SEMICOLON       reduce using rule 2 (neural_program_id -> EMPTY .)


state 6

    (1) PROGRAM -> PROGRAM_K ID neural_program_id SEMICOLON . BLOCK
    (3) BLOCK -> . VAR_BLOCK PROC_BLOCK PRINCIPAL_BLOCK
    (4) VAR_BLOCK -> . VARS_K BLOCKSTART VAR_DECL BLOCKEND

    VARS_K          shift and go to state 9

    BLOCK                          shift and go to state 7
    VAR_BLOCK                      shift and go to state 8

state 7

    (1) PROGRAM -> PROGRAM_K ID neural_program_id SEMICOLON BLOCK .

    $end            reduce using rule 1 (PROGRAM -> PROGRAM_K ID neural_program_id SEMICOLON BLOCK .)


state 8

    (3) BLOCK -> VAR_BLOCK . PROC_BLOCK PRINCIPAL_BLOCK
    (15) PROC_BLOCK -> . PROC_DECL
    (16) PROC_DECL -> . PROC_DECL_RETURN
    (17) PROC_DECL -> . PROC_DECL_VOID
    (18) PROC_DECL -> . EMPTY
    (21) PROC_DECL_RETURN -> . FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (19) PROC_DECL_VOID -> . FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (100) EMPTY -> .

    FUNCTION_K      shift and go to state 15
    MAIN_K          reduce using rule 100 (EMPTY -> .)

    PROC_BLOCK                     shift and go to state 10
    PROC_DECL                      shift and go to state 11
    PROC_DECL_RETURN               shift and go to state 12
    PROC_DECL_VOID                 shift and go to state 13
    EMPTY                          shift and go to state 14

state 9

    (4) VAR_BLOCK -> VARS_K . BLOCKSTART VAR_DECL BLOCKEND

    BLOCKSTART      shift and go to state 16


state 10

    (3) BLOCK -> VAR_BLOCK PROC_BLOCK . PRINCIPAL_BLOCK
    (96) PRINCIPAL_BLOCK -> . MAIN_K LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND

    MAIN_K          shift and go to state 18

    PRINCIPAL_BLOCK                shift and go to state 17

state 11

    (15) PROC_BLOCK -> PROC_DECL .

    MAIN_K          reduce using rule 15 (PROC_BLOCK -> PROC_DECL .)


state 12

    (16) PROC_DECL -> PROC_DECL_RETURN .

    MAIN_K          reduce using rule 16 (PROC_DECL -> PROC_DECL_RETURN .)


state 13

    (17) PROC_DECL -> PROC_DECL_VOID .

    MAIN_K          reduce using rule 17 (PROC_DECL -> PROC_DECL_VOID .)


state 14

    (18) PROC_DECL -> EMPTY .

    MAIN_K          reduce using rule 18 (PROC_DECL -> EMPTY .)


state 15

    (21) PROC_DECL_RETURN -> FUNCTION_K . TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (19) PROC_DECL_VOID -> FUNCTION_K . VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE

    VOID_K          shift and go to state 20
    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23

    TYPE                           shift and go to state 19

state 16

    (4) VAR_BLOCK -> VARS_K BLOCKSTART . VAR_DECL BLOCKEND
    (5) VAR_DECL -> . TYPE COLON VAR_LIST SEMICOLON VAR_DECL_R
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE

    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23

    VAR_DECL                       shift and go to state 24
    TYPE                           shift and go to state 25

state 17

    (3) BLOCK -> VAR_BLOCK PROC_BLOCK PRINCIPAL_BLOCK .

    $end            reduce using rule 3 (BLOCK -> VAR_BLOCK PROC_BLOCK PRINCIPAL_BLOCK .)


state 18

    (96) PRINCIPAL_BLOCK -> MAIN_K . LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND

    LPAREN          shift and go to state 26


state 19

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE . ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL

    ID              shift and go to state 27


state 20

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K . ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL

    ID              shift and go to state 28


state 21

    (11) TYPE -> INT_K . NEURAL_TYPE
    (14) NEURAL_TYPE -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    COLON           reduce using rule 100 (EMPTY -> .)

    NEURAL_TYPE                    shift and go to state 29
    EMPTY                          shift and go to state 30

state 22

    (12) TYPE -> FLOAT_K . NEURAL_TYPE
    (14) NEURAL_TYPE -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    COLON           reduce using rule 100 (EMPTY -> .)

    NEURAL_TYPE                    shift and go to state 31
    EMPTY                          shift and go to state 30

state 23

    (13) TYPE -> STRING_K . NEURAL_TYPE
    (14) NEURAL_TYPE -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    COLON           reduce using rule 100 (EMPTY -> .)

    NEURAL_TYPE                    shift and go to state 32
    EMPTY                          shift and go to state 30

state 24

    (4) VAR_BLOCK -> VARS_K BLOCKSTART VAR_DECL . BLOCKEND

    BLOCKEND        shift and go to state 33


state 25

    (5) VAR_DECL -> TYPE . COLON VAR_LIST SEMICOLON VAR_DECL_R

    COLON           shift and go to state 34


state 26

    (96) PRINCIPAL_BLOCK -> MAIN_K LPAREN . RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND

    RPAREN          shift and go to state 35


state 27

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID . neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (22) neural_proc_return_id -> . EMPTY
    (100) EMPTY -> .

    LPAREN          reduce using rule 100 (EMPTY -> .)

    neural_proc_return_id          shift and go to state 36
    EMPTY                          shift and go to state 37

state 28

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID . neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (20) neural_proc_void_id -> . EMPTY
    (100) EMPTY -> .

    LPAREN          reduce using rule 100 (EMPTY -> .)

    neural_proc_void_id            shift and go to state 38
    EMPTY                          shift and go to state 39

state 29

    (11) TYPE -> INT_K NEURAL_TYPE .

    ID              reduce using rule 11 (TYPE -> INT_K NEURAL_TYPE .)
    COLON           reduce using rule 11 (TYPE -> INT_K NEURAL_TYPE .)


state 30

    (14) NEURAL_TYPE -> EMPTY .

    ID              reduce using rule 14 (NEURAL_TYPE -> EMPTY .)
    COLON           reduce using rule 14 (NEURAL_TYPE -> EMPTY .)


state 31

    (12) TYPE -> FLOAT_K NEURAL_TYPE .

    ID              reduce using rule 12 (TYPE -> FLOAT_K NEURAL_TYPE .)
    COLON           reduce using rule 12 (TYPE -> FLOAT_K NEURAL_TYPE .)


state 32

    (13) TYPE -> STRING_K NEURAL_TYPE .

    ID              reduce using rule 13 (TYPE -> STRING_K NEURAL_TYPE .)
    COLON           reduce using rule 13 (TYPE -> STRING_K NEURAL_TYPE .)


state 33

    (4) VAR_BLOCK -> VARS_K BLOCKSTART VAR_DECL BLOCKEND .

    FUNCTION_K      reduce using rule 4 (VAR_BLOCK -> VARS_K BLOCKSTART VAR_DECL BLOCKEND .)
    MAIN_K          reduce using rule 4 (VAR_BLOCK -> VARS_K BLOCKSTART VAR_DECL BLOCKEND .)


state 34

    (5) VAR_DECL -> TYPE COLON . VAR_LIST SEMICOLON VAR_DECL_R
    (8) VAR_LIST -> . ID VAR_LIST2

    ID              shift and go to state 41

    VAR_LIST                       shift and go to state 40

state 35

    (96) PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN . BLOCKSTART PRINCIPAL_BODY BLOCKEND

    BLOCKSTART      shift and go to state 42


state 36

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id . LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL

    LPAREN          shift and go to state 43


state 37

    (22) neural_proc_return_id -> EMPTY .

    LPAREN          reduce using rule 22 (neural_proc_return_id -> EMPTY .)


state 38

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id . LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL

    LPAREN          shift and go to state 44


state 39

    (20) neural_proc_void_id -> EMPTY .

    LPAREN          reduce using rule 20 (neural_proc_void_id -> EMPTY .)


state 40

    (5) VAR_DECL -> TYPE COLON VAR_LIST . SEMICOLON VAR_DECL_R

    SEMICOLON       shift and go to state 45


state 41

    (8) VAR_LIST -> ID . VAR_LIST2
    (9) VAR_LIST2 -> . COMMA ID VAR_LIST2
    (10) VAR_LIST2 -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 47
    SEMICOLON       reduce using rule 100 (EMPTY -> .)

    VAR_LIST2                      shift and go to state 46
    EMPTY                          shift and go to state 48

state 42

    (96) PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN BLOCKSTART . PRINCIPAL_BODY BLOCKEND
    (97) PRINCIPAL_BODY -> . STATEMENT PRINCIPAL_BODY_R
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    PRINCIPAL_BODY                 shift and go to state 49
    STATEMENT                      shift and go to state 50
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 43

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN . PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (24) PARAM_DECL -> . TYPE ID neuro PARAM_DECL_R
    (25) PARAM_DECL -> . EMPTY
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE
    (100) EMPTY -> .

    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23
    RPAREN          reduce using rule 100 (EMPTY -> .)

    TYPE                           shift and go to state 68
    PARAM_DECL                     shift and go to state 69
    EMPTY                          shift and go to state 70

state 44

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN . PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (24) PARAM_DECL -> . TYPE ID neuro PARAM_DECL_R
    (25) PARAM_DECL -> . EMPTY
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE
    (100) EMPTY -> .

    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23
    RPAREN          reduce using rule 100 (EMPTY -> .)

    PARAM_DECL                     shift and go to state 71
    TYPE                           shift and go to state 68
    EMPTY                          shift and go to state 70

state 45

    (5) VAR_DECL -> TYPE COLON VAR_LIST SEMICOLON . VAR_DECL_R
    (6) VAR_DECL_R -> . VAR_DECL
    (7) VAR_DECL_R -> . EMPTY
    (5) VAR_DECL -> . TYPE COLON VAR_LIST SEMICOLON VAR_DECL_R
    (100) EMPTY -> .
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23

    TYPE                           shift and go to state 25
    VAR_DECL_R                     shift and go to state 72
    VAR_DECL                       shift and go to state 73
    EMPTY                          shift and go to state 74

state 46

    (8) VAR_LIST -> ID VAR_LIST2 .

    SEMICOLON       reduce using rule 8 (VAR_LIST -> ID VAR_LIST2 .)


state 47

    (9) VAR_LIST2 -> COMMA . ID VAR_LIST2

    ID              shift and go to state 75


state 48

    (10) VAR_LIST2 -> EMPTY .

    SEMICOLON       reduce using rule 10 (VAR_LIST2 -> EMPTY .)


state 49

    (96) PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY . BLOCKEND

    BLOCKEND        shift and go to state 76


state 50

    (97) PRINCIPAL_BODY -> STATEMENT . PRINCIPAL_BODY_R
    (98) PRINCIPAL_BODY_R -> . PRINCIPAL_BODY
    (99) PRINCIPAL_BODY_R -> . EMPTY
    (97) PRINCIPAL_BODY -> . STATEMENT PRINCIPAL_BODY_R
    (100) EMPTY -> .
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT                      shift and go to state 50
    PRINCIPAL_BODY_R               shift and go to state 77
    PRINCIPAL_BODY                 shift and go to state 78
    EMPTY                          shift and go to state 79
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 51

    (32) STATEMENT -> ASSIGN . SEMICOLON

    SEMICOLON       shift and go to state 80


state 52

    (33) STATEMENT -> FUNC_CALL . SEMICOLON

    SEMICOLON       shift and go to state 81


state 53

    (34) STATEMENT -> READ . SEMICOLON

    SEMICOLON       shift and go to state 82


state 54

    (35) STATEMENT -> WRITE . SEMICOLON

    SEMICOLON       shift and go to state 83


state 55

    (36) STATEMENT -> FLOW .

    ID              reduce using rule 36 (STATEMENT -> FLOW .)
    READ_K          reduce using rule 36 (STATEMENT -> FLOW .)
    WRITE_K         reduce using rule 36 (STATEMENT -> FLOW .)
    IF_K            reduce using rule 36 (STATEMENT -> FLOW .)
    WHILE_K         reduce using rule 36 (STATEMENT -> FLOW .)
    FOR_K           reduce using rule 36 (STATEMENT -> FLOW .)
    BLOCKEND        reduce using rule 36 (STATEMENT -> FLOW .)
    RETURN_K        reduce using rule 36 (STATEMENT -> FLOW .)


state 56

    (49) ASSIGN -> VAR . EQUALS H_EXPRESSION

    EQUALS          shift and go to state 84


state 57

    (53) FUNC_CALL -> ID . LPAREN ARG_LIST RPAREN
    (50) VAR -> ID .
    (52) ARRAY -> ID . LBRACE INT RBRACE

    LPAREN          shift and go to state 85
    EQUALS          reduce using rule 50 (VAR -> ID .)
    LBRACE          shift and go to state 86


state 58

    (62) READ -> READ_K . ID_LIST
    (63) ID_LIST -> . ID ID_LIST_R

    ID              shift and go to state 88

    ID_LIST                        shift and go to state 87

state 59

    (66) WRITE -> WRITE_K . WRITE_LIST
    (67) WRITE_LIST -> . H_EXPRESSION WRITE_LIST_R
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    WRITE_LIST                     shift and go to state 89
    H_EXPRESSION                   shift and go to state 90
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 60

    (37) FLOW -> DECISION .

    ID              reduce using rule 37 (FLOW -> DECISION .)
    READ_K          reduce using rule 37 (FLOW -> DECISION .)
    WRITE_K         reduce using rule 37 (FLOW -> DECISION .)
    IF_K            reduce using rule 37 (FLOW -> DECISION .)
    WHILE_K         reduce using rule 37 (FLOW -> DECISION .)
    FOR_K           reduce using rule 37 (FLOW -> DECISION .)
    BLOCKEND        reduce using rule 37 (FLOW -> DECISION .)
    RETURN_K        reduce using rule 37 (FLOW -> DECISION .)


state 61

    (38) FLOW -> LOOP .

    ID              reduce using rule 38 (FLOW -> LOOP .)
    READ_K          reduce using rule 38 (FLOW -> LOOP .)
    WRITE_K         reduce using rule 38 (FLOW -> LOOP .)
    IF_K            reduce using rule 38 (FLOW -> LOOP .)
    WHILE_K         reduce using rule 38 (FLOW -> LOOP .)
    FOR_K           reduce using rule 38 (FLOW -> LOOP .)
    BLOCKEND        reduce using rule 38 (FLOW -> LOOP .)
    RETURN_K        reduce using rule 38 (FLOW -> LOOP .)


state 62

    (51) VAR -> ARRAY .

    EQUALS          reduce using rule 51 (VAR -> ARRAY .)
    COMMA           reduce using rule 51 (VAR -> ARRAY .)
    RPAREN          reduce using rule 51 (VAR -> ARRAY .)


state 63

    (43) DECISION -> IF_K . LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT

    LPAREN          shift and go to state 101


state 64

    (39) LOOP -> WHILE_LOOP .

    ID              reduce using rule 39 (LOOP -> WHILE_LOOP .)
    READ_K          reduce using rule 39 (LOOP -> WHILE_LOOP .)
    WRITE_K         reduce using rule 39 (LOOP -> WHILE_LOOP .)
    IF_K            reduce using rule 39 (LOOP -> WHILE_LOOP .)
    WHILE_K         reduce using rule 39 (LOOP -> WHILE_LOOP .)
    FOR_K           reduce using rule 39 (LOOP -> WHILE_LOOP .)
    BLOCKEND        reduce using rule 39 (LOOP -> WHILE_LOOP .)
    RETURN_K        reduce using rule 39 (LOOP -> WHILE_LOOP .)


state 65

    (40) LOOP -> FOR_LOOP .

    ID              reduce using rule 40 (LOOP -> FOR_LOOP .)
    READ_K          reduce using rule 40 (LOOP -> FOR_LOOP .)
    WRITE_K         reduce using rule 40 (LOOP -> FOR_LOOP .)
    IF_K            reduce using rule 40 (LOOP -> FOR_LOOP .)
    WHILE_K         reduce using rule 40 (LOOP -> FOR_LOOP .)
    FOR_K           reduce using rule 40 (LOOP -> FOR_LOOP .)
    BLOCKEND        reduce using rule 40 (LOOP -> FOR_LOOP .)
    RETURN_K        reduce using rule 40 (LOOP -> FOR_LOOP .)


state 66

    (41) WHILE_LOOP -> WHILE_K . LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND

    LPAREN          shift and go to state 102


state 67

    (42) FOR_LOOP -> FOR_K . ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    ID              shift and go to state 103


state 68

    (24) PARAM_DECL -> TYPE . ID neuro PARAM_DECL_R

    ID              shift and go to state 104


state 69

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL . RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL

    RPAREN          shift and go to state 105


state 70

    (25) PARAM_DECL -> EMPTY .

    RPAREN          reduce using rule 25 (PARAM_DECL -> EMPTY .)


state 71

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL . RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL

    RPAREN          shift and go to state 106


state 72

    (5) VAR_DECL -> TYPE COLON VAR_LIST SEMICOLON VAR_DECL_R .

    BLOCKEND        reduce using rule 5 (VAR_DECL -> TYPE COLON VAR_LIST SEMICOLON VAR_DECL_R .)


state 73

    (6) VAR_DECL_R -> VAR_DECL .

    BLOCKEND        reduce using rule 6 (VAR_DECL_R -> VAR_DECL .)


state 74

    (7) VAR_DECL_R -> EMPTY .

    BLOCKEND        reduce using rule 7 (VAR_DECL_R -> EMPTY .)


state 75

    (9) VAR_LIST2 -> COMMA ID . VAR_LIST2
    (9) VAR_LIST2 -> . COMMA ID VAR_LIST2
    (10) VAR_LIST2 -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 47
    SEMICOLON       reduce using rule 100 (EMPTY -> .)

    VAR_LIST2                      shift and go to state 107
    EMPTY                          shift and go to state 48

state 76

    (96) PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND .

    $end            reduce using rule 96 (PRINCIPAL_BLOCK -> MAIN_K LPAREN RPAREN BLOCKSTART PRINCIPAL_BODY BLOCKEND .)


state 77

    (97) PRINCIPAL_BODY -> STATEMENT PRINCIPAL_BODY_R .

    BLOCKEND        reduce using rule 97 (PRINCIPAL_BODY -> STATEMENT PRINCIPAL_BODY_R .)


state 78

    (98) PRINCIPAL_BODY_R -> PRINCIPAL_BODY .

    BLOCKEND        reduce using rule 98 (PRINCIPAL_BODY_R -> PRINCIPAL_BODY .)


state 79

    (99) PRINCIPAL_BODY_R -> EMPTY .

    BLOCKEND        reduce using rule 99 (PRINCIPAL_BODY_R -> EMPTY .)


state 80

    (32) STATEMENT -> ASSIGN SEMICOLON .

    ID              reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    READ_K          reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    WRITE_K         reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    IF_K            reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    WHILE_K         reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    FOR_K           reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    BLOCKEND        reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)
    RETURN_K        reduce using rule 32 (STATEMENT -> ASSIGN SEMICOLON .)


state 81

    (33) STATEMENT -> FUNC_CALL SEMICOLON .

    ID              reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    READ_K          reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    WRITE_K         reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    IF_K            reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    WHILE_K         reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    FOR_K           reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    BLOCKEND        reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)
    RETURN_K        reduce using rule 33 (STATEMENT -> FUNC_CALL SEMICOLON .)


state 82

    (34) STATEMENT -> READ SEMICOLON .

    ID              reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    READ_K          reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    WRITE_K         reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    IF_K            reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    WHILE_K         reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    FOR_K           reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    BLOCKEND        reduce using rule 34 (STATEMENT -> READ SEMICOLON .)
    RETURN_K        reduce using rule 34 (STATEMENT -> READ SEMICOLON .)


state 83

    (35) STATEMENT -> WRITE SEMICOLON .

    ID              reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    READ_K          reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    WRITE_K         reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    IF_K            reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    WHILE_K         reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    FOR_K           reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    BLOCKEND        reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)
    RETURN_K        reduce using rule 35 (STATEMENT -> WRITE SEMICOLON .)


state 84

    (49) ASSIGN -> VAR EQUALS . H_EXPRESSION
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 108
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 85

    (53) FUNC_CALL -> ID LPAREN . ARG_LIST RPAREN
    (54) ARG_LIST -> . VAR ARG_LIST_R
    (55) ARG_LIST -> . CONSTANT ARG_LIST_R
    (56) ARG_LIST -> . ARG_LIST_R
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING
    (57) ARG_LIST_R -> . COMMA ARG_LIST
    (58) ARG_LIST_R -> . EMPTY
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (100) EMPTY -> .

    ID              shift and go to state 109
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100
    COMMA           shift and go to state 114
    RPAREN          reduce using rule 100 (EMPTY -> .)

    ARG_LIST                       shift and go to state 110
    VAR                            shift and go to state 111
    ARG_LIST_R                     shift and go to state 112
    CONSTANT                       shift and go to state 113
    ARRAY                          shift and go to state 62
    EMPTY                          shift and go to state 115

state 86

    (52) ARRAY -> ID LBRACE . INT RBRACE

    INT             shift and go to state 116


state 87

    (62) READ -> READ_K ID_LIST .

    SEMICOLON       reduce using rule 62 (READ -> READ_K ID_LIST .)


state 88

    (63) ID_LIST -> ID . ID_LIST_R
    (64) ID_LIST_R -> . COMMA ID_LIST
    (65) ID_LIST_R -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 118
    SEMICOLON       reduce using rule 100 (EMPTY -> .)

    ID_LIST_R                      shift and go to state 117
    EMPTY                          shift and go to state 119

state 89

    (66) WRITE -> WRITE_K WRITE_LIST .

    SEMICOLON       reduce using rule 66 (WRITE -> WRITE_K WRITE_LIST .)


state 90

    (67) WRITE_LIST -> H_EXPRESSION . WRITE_LIST_R
    (68) WRITE_LIST_R -> . COMMA H_EXPRESSION
    (69) WRITE_LIST_R -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 121
    SEMICOLON       reduce using rule 100 (EMPTY -> .)

    WRITE_LIST_R                   shift and go to state 120
    EMPTY                          shift and go to state 122

state 91

    (92) H_EXPRESSION -> S_EXPRESSION . H_EXPRESSION_R
    (93) H_EXPRESSION_R -> . OR H_EXPRESSION
    (94) H_EXPRESSION_R -> . AND H_EXPRESSION
    (95) H_EXPRESSION_R -> . EMPTY
    (100) EMPTY -> .

    OR              shift and go to state 124
    AND             shift and go to state 125
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    H_EXPRESSION_R                 shift and go to state 123
    EMPTY                          shift and go to state 126

state 92

    (89) S_EXPRESSION -> EXPRESSION .
    (90) S_EXPRESSION -> EXPRESSION . GT EXPRESSION
    (91) S_EXPRESSION -> EXPRESSION . LT EXPRESSION

    OR              reduce using rule 89 (S_EXPRESSION -> EXPRESSION .)
    AND             reduce using rule 89 (S_EXPRESSION -> EXPRESSION .)
    COMMA           reduce using rule 89 (S_EXPRESSION -> EXPRESSION .)
    SEMICOLON       reduce using rule 89 (S_EXPRESSION -> EXPRESSION .)
    RPAREN          reduce using rule 89 (S_EXPRESSION -> EXPRESSION .)
    GT              shift and go to state 127
    LT              shift and go to state 128


state 93

    (71) EXPRESSION -> TERM . NEURAL_EXPRESSION EXPRESSION_R
    (72) NEURAL_EXPRESSION -> . EMPTY
    (100) EMPTY -> .

    PLUS            reduce using rule 100 (EMPTY -> .)
    MINUS           reduce using rule 100 (EMPTY -> .)
    GT              reduce using rule 100 (EMPTY -> .)
    LT              reduce using rule 100 (EMPTY -> .)
    OR              reduce using rule 100 (EMPTY -> .)
    AND             reduce using rule 100 (EMPTY -> .)
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    NEURAL_EXPRESSION              shift and go to state 129
    EMPTY                          shift and go to state 130

state 94

    (78) TERM -> FACTOR . NEURAL_TERM TERM_R
    (79) NEURAL_TERM -> . EMPTY
    (100) EMPTY -> .

    TIMES           reduce using rule 100 (EMPTY -> .)
    DIVIDE          reduce using rule 100 (EMPTY -> .)
    PLUS            reduce using rule 100 (EMPTY -> .)
    MINUS           reduce using rule 100 (EMPTY -> .)
    GT              reduce using rule 100 (EMPTY -> .)
    LT              reduce using rule 100 (EMPTY -> .)
    OR              reduce using rule 100 (EMPTY -> .)
    AND             reduce using rule 100 (EMPTY -> .)
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    NEURAL_TERM                    shift and go to state 131
    EMPTY                          shift and go to state 132

state 95

    (85) FACTOR -> ID . NEURAL_ID
    (88) NEURAL_ID -> . EMPTY
    (100) EMPTY -> .

    TIMES           reduce using rule 100 (EMPTY -> .)
    DIVIDE          reduce using rule 100 (EMPTY -> .)
    PLUS            reduce using rule 100 (EMPTY -> .)
    MINUS           reduce using rule 100 (EMPTY -> .)
    GT              reduce using rule 100 (EMPTY -> .)
    LT              reduce using rule 100 (EMPTY -> .)
    OR              reduce using rule 100 (EMPTY -> .)
    AND             reduce using rule 100 (EMPTY -> .)
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    NEURAL_ID                      shift and go to state 133
    EMPTY                          shift and go to state 134

state 96

    (86) FACTOR -> CONSTANT .

    TIMES           reduce using rule 86 (FACTOR -> CONSTANT .)
    DIVIDE          reduce using rule 86 (FACTOR -> CONSTANT .)
    PLUS            reduce using rule 86 (FACTOR -> CONSTANT .)
    MINUS           reduce using rule 86 (FACTOR -> CONSTANT .)
    GT              reduce using rule 86 (FACTOR -> CONSTANT .)
    LT              reduce using rule 86 (FACTOR -> CONSTANT .)
    OR              reduce using rule 86 (FACTOR -> CONSTANT .)
    AND             reduce using rule 86 (FACTOR -> CONSTANT .)
    COMMA           reduce using rule 86 (FACTOR -> CONSTANT .)
    SEMICOLON       reduce using rule 86 (FACTOR -> CONSTANT .)
    RPAREN          reduce using rule 86 (FACTOR -> CONSTANT .)


state 97

    (87) FACTOR -> LPAREN . EXPRESSION RPAREN
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    EXPRESSION                     shift and go to state 135
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 98

    (59) CONSTANT -> INT .

    TIMES           reduce using rule 59 (CONSTANT -> INT .)
    DIVIDE          reduce using rule 59 (CONSTANT -> INT .)
    PLUS            reduce using rule 59 (CONSTANT -> INT .)
    MINUS           reduce using rule 59 (CONSTANT -> INT .)
    GT              reduce using rule 59 (CONSTANT -> INT .)
    LT              reduce using rule 59 (CONSTANT -> INT .)
    OR              reduce using rule 59 (CONSTANT -> INT .)
    AND             reduce using rule 59 (CONSTANT -> INT .)
    COMMA           reduce using rule 59 (CONSTANT -> INT .)
    SEMICOLON       reduce using rule 59 (CONSTANT -> INT .)
    RPAREN          reduce using rule 59 (CONSTANT -> INT .)


state 99

    (60) CONSTANT -> FLOAT .

    TIMES           reduce using rule 60 (CONSTANT -> FLOAT .)
    DIVIDE          reduce using rule 60 (CONSTANT -> FLOAT .)
    PLUS            reduce using rule 60 (CONSTANT -> FLOAT .)
    MINUS           reduce using rule 60 (CONSTANT -> FLOAT .)
    GT              reduce using rule 60 (CONSTANT -> FLOAT .)
    LT              reduce using rule 60 (CONSTANT -> FLOAT .)
    OR              reduce using rule 60 (CONSTANT -> FLOAT .)
    AND             reduce using rule 60 (CONSTANT -> FLOAT .)
    COMMA           reduce using rule 60 (CONSTANT -> FLOAT .)
    SEMICOLON       reduce using rule 60 (CONSTANT -> FLOAT .)
    RPAREN          reduce using rule 60 (CONSTANT -> FLOAT .)


state 100

    (61) CONSTANT -> STRING .

    TIMES           reduce using rule 61 (CONSTANT -> STRING .)
    DIVIDE          reduce using rule 61 (CONSTANT -> STRING .)
    PLUS            reduce using rule 61 (CONSTANT -> STRING .)
    MINUS           reduce using rule 61 (CONSTANT -> STRING .)
    GT              reduce using rule 61 (CONSTANT -> STRING .)
    LT              reduce using rule 61 (CONSTANT -> STRING .)
    OR              reduce using rule 61 (CONSTANT -> STRING .)
    AND             reduce using rule 61 (CONSTANT -> STRING .)
    COMMA           reduce using rule 61 (CONSTANT -> STRING .)
    SEMICOLON       reduce using rule 61 (CONSTANT -> STRING .)
    RPAREN          reduce using rule 61 (CONSTANT -> STRING .)


state 101

    (43) DECISION -> IF_K LPAREN . H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 136
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 102

    (41) WHILE_LOOP -> WHILE_K LPAREN . H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 137
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 103

    (42) FOR_LOOP -> FOR_K ID . EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    EQUALS          shift and go to state 138


state 104

    (24) PARAM_DECL -> TYPE ID . neuro PARAM_DECL_R
    (26) neuro -> . EMPTY
    (100) EMPTY -> .

    COMMA           reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    neuro                          shift and go to state 139
    EMPTY                          shift and go to state 140

state 105

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN . neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (23) neural_param_decl -> . EMPTY
    (100) EMPTY -> .

    BLOCKSTART      reduce using rule 100 (EMPTY -> .)

    neural_param_decl              shift and go to state 141
    EMPTY                          shift and go to state 142

state 106

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN . neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (23) neural_param_decl -> . EMPTY
    (100) EMPTY -> .

    BLOCKSTART      reduce using rule 100 (EMPTY -> .)

    neural_param_decl              shift and go to state 143
    EMPTY                          shift and go to state 142

state 107

    (9) VAR_LIST2 -> COMMA ID VAR_LIST2 .

    SEMICOLON       reduce using rule 9 (VAR_LIST2 -> COMMA ID VAR_LIST2 .)


state 108

    (49) ASSIGN -> VAR EQUALS H_EXPRESSION .

    SEMICOLON       reduce using rule 49 (ASSIGN -> VAR EQUALS H_EXPRESSION .)


state 109

    (50) VAR -> ID .
    (52) ARRAY -> ID . LBRACE INT RBRACE

    COMMA           reduce using rule 50 (VAR -> ID .)
    RPAREN          reduce using rule 50 (VAR -> ID .)
    LBRACE          shift and go to state 86


state 110

    (53) FUNC_CALL -> ID LPAREN ARG_LIST . RPAREN

    RPAREN          shift and go to state 144


state 111

    (54) ARG_LIST -> VAR . ARG_LIST_R
    (57) ARG_LIST_R -> . COMMA ARG_LIST
    (58) ARG_LIST_R -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 114
    RPAREN          reduce using rule 100 (EMPTY -> .)

    ARG_LIST_R                     shift and go to state 145
    EMPTY                          shift and go to state 115

state 112

    (56) ARG_LIST -> ARG_LIST_R .

    RPAREN          reduce using rule 56 (ARG_LIST -> ARG_LIST_R .)


state 113

    (55) ARG_LIST -> CONSTANT . ARG_LIST_R
    (57) ARG_LIST_R -> . COMMA ARG_LIST
    (58) ARG_LIST_R -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 114
    RPAREN          reduce using rule 100 (EMPTY -> .)

    ARG_LIST_R                     shift and go to state 146
    EMPTY                          shift and go to state 115

state 114

    (57) ARG_LIST_R -> COMMA . ARG_LIST
    (54) ARG_LIST -> . VAR ARG_LIST_R
    (55) ARG_LIST -> . CONSTANT ARG_LIST_R
    (56) ARG_LIST -> . ARG_LIST_R
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING
    (57) ARG_LIST_R -> . COMMA ARG_LIST
    (58) ARG_LIST_R -> . EMPTY
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (100) EMPTY -> .

    ID              shift and go to state 109
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100
    COMMA           shift and go to state 114
    RPAREN          reduce using rule 100 (EMPTY -> .)

    ARG_LIST                       shift and go to state 147
    VAR                            shift and go to state 111
    ARG_LIST_R                     shift and go to state 112
    CONSTANT                       shift and go to state 113
    ARRAY                          shift and go to state 62
    EMPTY                          shift and go to state 115

state 115

    (58) ARG_LIST_R -> EMPTY .

    RPAREN          reduce using rule 58 (ARG_LIST_R -> EMPTY .)


state 116

    (52) ARRAY -> ID LBRACE INT . RBRACE

    RBRACE          shift and go to state 148


state 117

    (63) ID_LIST -> ID ID_LIST_R .

    SEMICOLON       reduce using rule 63 (ID_LIST -> ID ID_LIST_R .)


state 118

    (64) ID_LIST_R -> COMMA . ID_LIST
    (63) ID_LIST -> . ID ID_LIST_R

    ID              shift and go to state 88

    ID_LIST                        shift and go to state 149

state 119

    (65) ID_LIST_R -> EMPTY .

    SEMICOLON       reduce using rule 65 (ID_LIST_R -> EMPTY .)


state 120

    (67) WRITE_LIST -> H_EXPRESSION WRITE_LIST_R .

    SEMICOLON       reduce using rule 67 (WRITE_LIST -> H_EXPRESSION WRITE_LIST_R .)


state 121

    (68) WRITE_LIST_R -> COMMA . H_EXPRESSION
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 150
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 122

    (69) WRITE_LIST_R -> EMPTY .

    SEMICOLON       reduce using rule 69 (WRITE_LIST_R -> EMPTY .)


state 123

    (92) H_EXPRESSION -> S_EXPRESSION H_EXPRESSION_R .

    COMMA           reduce using rule 92 (H_EXPRESSION -> S_EXPRESSION H_EXPRESSION_R .)
    SEMICOLON       reduce using rule 92 (H_EXPRESSION -> S_EXPRESSION H_EXPRESSION_R .)
    RPAREN          reduce using rule 92 (H_EXPRESSION -> S_EXPRESSION H_EXPRESSION_R .)


state 124

    (93) H_EXPRESSION_R -> OR . H_EXPRESSION
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 151
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 125

    (94) H_EXPRESSION_R -> AND . H_EXPRESSION
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 152
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 126

    (95) H_EXPRESSION_R -> EMPTY .

    COMMA           reduce using rule 95 (H_EXPRESSION_R -> EMPTY .)
    SEMICOLON       reduce using rule 95 (H_EXPRESSION_R -> EMPTY .)
    RPAREN          reduce using rule 95 (H_EXPRESSION_R -> EMPTY .)


state 127

    (90) S_EXPRESSION -> EXPRESSION GT . EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    EXPRESSION                     shift and go to state 153
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 128

    (91) S_EXPRESSION -> EXPRESSION LT . EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    EXPRESSION                     shift and go to state 154
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 129

    (71) EXPRESSION -> TERM NEURAL_EXPRESSION . EXPRESSION_R
    (73) EXPRESSION_R -> . PLUS NEURAL_PLUS EXPRESSION
    (74) EXPRESSION_R -> . MINUS NEURAL_MINUS EXPRESSION
    (75) EXPRESSION_R -> . EMPTY
    (100) EMPTY -> .

    PLUS            shift and go to state 156
    MINUS           shift and go to state 157
    GT              reduce using rule 100 (EMPTY -> .)
    LT              reduce using rule 100 (EMPTY -> .)
    OR              reduce using rule 100 (EMPTY -> .)
    AND             reduce using rule 100 (EMPTY -> .)
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    EXPRESSION_R                   shift and go to state 155
    EMPTY                          shift and go to state 158

state 130

    (72) NEURAL_EXPRESSION -> EMPTY .

    PLUS            reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    MINUS           reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    GT              reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    LT              reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    OR              reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    AND             reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    COMMA           reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    SEMICOLON       reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)
    RPAREN          reduce using rule 72 (NEURAL_EXPRESSION -> EMPTY .)


state 131

    (78) TERM -> FACTOR NEURAL_TERM . TERM_R
    (80) TERM_R -> . TIMES NEURAL_TIMES TERM
    (81) TERM_R -> . DIVIDE NEURAL_DIVIDE TERM
    (82) TERM_R -> . EMPTY
    (100) EMPTY -> .

    TIMES           shift and go to state 160
    DIVIDE          shift and go to state 161
    PLUS            reduce using rule 100 (EMPTY -> .)
    MINUS           reduce using rule 100 (EMPTY -> .)
    GT              reduce using rule 100 (EMPTY -> .)
    LT              reduce using rule 100 (EMPTY -> .)
    OR              reduce using rule 100 (EMPTY -> .)
    AND             reduce using rule 100 (EMPTY -> .)
    COMMA           reduce using rule 100 (EMPTY -> .)
    SEMICOLON       reduce using rule 100 (EMPTY -> .)
    RPAREN          reduce using rule 100 (EMPTY -> .)

    TERM_R                         shift and go to state 159
    EMPTY                          shift and go to state 162

state 132

    (79) NEURAL_TERM -> EMPTY .

    TIMES           reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    DIVIDE          reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    PLUS            reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    MINUS           reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    GT              reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    LT              reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    OR              reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    AND             reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    COMMA           reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    SEMICOLON       reduce using rule 79 (NEURAL_TERM -> EMPTY .)
    RPAREN          reduce using rule 79 (NEURAL_TERM -> EMPTY .)


state 133

    (85) FACTOR -> ID NEURAL_ID .

    TIMES           reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    DIVIDE          reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    PLUS            reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    MINUS           reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    GT              reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    LT              reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    OR              reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    AND             reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    COMMA           reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    SEMICOLON       reduce using rule 85 (FACTOR -> ID NEURAL_ID .)
    RPAREN          reduce using rule 85 (FACTOR -> ID NEURAL_ID .)


state 134

    (88) NEURAL_ID -> EMPTY .

    TIMES           reduce using rule 88 (NEURAL_ID -> EMPTY .)
    DIVIDE          reduce using rule 88 (NEURAL_ID -> EMPTY .)
    PLUS            reduce using rule 88 (NEURAL_ID -> EMPTY .)
    MINUS           reduce using rule 88 (NEURAL_ID -> EMPTY .)
    GT              reduce using rule 88 (NEURAL_ID -> EMPTY .)
    LT              reduce using rule 88 (NEURAL_ID -> EMPTY .)
    OR              reduce using rule 88 (NEURAL_ID -> EMPTY .)
    AND             reduce using rule 88 (NEURAL_ID -> EMPTY .)
    COMMA           reduce using rule 88 (NEURAL_ID -> EMPTY .)
    SEMICOLON       reduce using rule 88 (NEURAL_ID -> EMPTY .)
    RPAREN          reduce using rule 88 (NEURAL_ID -> EMPTY .)


state 135

    (87) FACTOR -> LPAREN EXPRESSION . RPAREN

    RPAREN          shift and go to state 163


state 136

    (43) DECISION -> IF_K LPAREN H_EXPRESSION . RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT

    RPAREN          shift and go to state 164


state 137

    (41) WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION . RPAREN BLOCKSTART STATEMENT_R BLOCKEND

    RPAREN          shift and go to state 165


state 138

    (42) FOR_LOOP -> FOR_K ID EQUALS . INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    INT             shift and go to state 166


state 139

    (24) PARAM_DECL -> TYPE ID neuro . PARAM_DECL_R
    (27) PARAM_DECL_R -> . COMMA PARAM_DECL
    (28) PARAM_DECL_R -> . EMPTY
    (100) EMPTY -> .

    COMMA           shift and go to state 168
    RPAREN          reduce using rule 100 (EMPTY -> .)

    PARAM_DECL_R                   shift and go to state 167
    EMPTY                          shift and go to state 169

state 140

    (26) neuro -> EMPTY .

    COMMA           reduce using rule 26 (neuro -> EMPTY .)
    RPAREN          reduce using rule 26 (neuro -> EMPTY .)


state 141

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl . BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL

    BLOCKSTART      shift and go to state 170


state 142

    (23) neural_param_decl -> EMPTY .

    BLOCKSTART      reduce using rule 23 (neural_param_decl -> EMPTY .)


state 143

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl . BLOCKSTART PROC_BODY BLOCKEND PROC_DECL

    BLOCKSTART      shift and go to state 171


state 144

    (53) FUNC_CALL -> ID LPAREN ARG_LIST RPAREN .

    SEMICOLON       reduce using rule 53 (FUNC_CALL -> ID LPAREN ARG_LIST RPAREN .)


state 145

    (54) ARG_LIST -> VAR ARG_LIST_R .

    RPAREN          reduce using rule 54 (ARG_LIST -> VAR ARG_LIST_R .)


state 146

    (55) ARG_LIST -> CONSTANT ARG_LIST_R .

    RPAREN          reduce using rule 55 (ARG_LIST -> CONSTANT ARG_LIST_R .)


state 147

    (57) ARG_LIST_R -> COMMA ARG_LIST .

    RPAREN          reduce using rule 57 (ARG_LIST_R -> COMMA ARG_LIST .)


state 148

    (52) ARRAY -> ID LBRACE INT RBRACE .

    EQUALS          reduce using rule 52 (ARRAY -> ID LBRACE INT RBRACE .)
    COMMA           reduce using rule 52 (ARRAY -> ID LBRACE INT RBRACE .)
    RPAREN          reduce using rule 52 (ARRAY -> ID LBRACE INT RBRACE .)


state 149

    (64) ID_LIST_R -> COMMA ID_LIST .

    SEMICOLON       reduce using rule 64 (ID_LIST_R -> COMMA ID_LIST .)


state 150

    (68) WRITE_LIST_R -> COMMA H_EXPRESSION .

    SEMICOLON       reduce using rule 68 (WRITE_LIST_R -> COMMA H_EXPRESSION .)


state 151

    (93) H_EXPRESSION_R -> OR H_EXPRESSION .

    COMMA           reduce using rule 93 (H_EXPRESSION_R -> OR H_EXPRESSION .)
    SEMICOLON       reduce using rule 93 (H_EXPRESSION_R -> OR H_EXPRESSION .)
    RPAREN          reduce using rule 93 (H_EXPRESSION_R -> OR H_EXPRESSION .)


state 152

    (94) H_EXPRESSION_R -> AND H_EXPRESSION .

    COMMA           reduce using rule 94 (H_EXPRESSION_R -> AND H_EXPRESSION .)
    SEMICOLON       reduce using rule 94 (H_EXPRESSION_R -> AND H_EXPRESSION .)
    RPAREN          reduce using rule 94 (H_EXPRESSION_R -> AND H_EXPRESSION .)


state 153

    (90) S_EXPRESSION -> EXPRESSION GT EXPRESSION .

    OR              reduce using rule 90 (S_EXPRESSION -> EXPRESSION GT EXPRESSION .)
    AND             reduce using rule 90 (S_EXPRESSION -> EXPRESSION GT EXPRESSION .)
    COMMA           reduce using rule 90 (S_EXPRESSION -> EXPRESSION GT EXPRESSION .)
    SEMICOLON       reduce using rule 90 (S_EXPRESSION -> EXPRESSION GT EXPRESSION .)
    RPAREN          reduce using rule 90 (S_EXPRESSION -> EXPRESSION GT EXPRESSION .)


state 154

    (91) S_EXPRESSION -> EXPRESSION LT EXPRESSION .

    OR              reduce using rule 91 (S_EXPRESSION -> EXPRESSION LT EXPRESSION .)
    AND             reduce using rule 91 (S_EXPRESSION -> EXPRESSION LT EXPRESSION .)
    COMMA           reduce using rule 91 (S_EXPRESSION -> EXPRESSION LT EXPRESSION .)
    SEMICOLON       reduce using rule 91 (S_EXPRESSION -> EXPRESSION LT EXPRESSION .)
    RPAREN          reduce using rule 91 (S_EXPRESSION -> EXPRESSION LT EXPRESSION .)


state 155

    (71) EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .

    GT              reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    LT              reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    OR              reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    AND             reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    COMMA           reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    SEMICOLON       reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)
    RPAREN          reduce using rule 71 (EXPRESSION -> TERM NEURAL_EXPRESSION EXPRESSION_R .)


state 156

    (73) EXPRESSION_R -> PLUS . NEURAL_PLUS EXPRESSION
    (76) NEURAL_PLUS -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    LPAREN          reduce using rule 100 (EMPTY -> .)
    INT             reduce using rule 100 (EMPTY -> .)
    FLOAT           reduce using rule 100 (EMPTY -> .)
    STRING          reduce using rule 100 (EMPTY -> .)

    NEURAL_PLUS                    shift and go to state 172
    EMPTY                          shift and go to state 173

state 157

    (74) EXPRESSION_R -> MINUS . NEURAL_MINUS EXPRESSION
    (77) NEURAL_MINUS -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    LPAREN          reduce using rule 100 (EMPTY -> .)
    INT             reduce using rule 100 (EMPTY -> .)
    FLOAT           reduce using rule 100 (EMPTY -> .)
    STRING          reduce using rule 100 (EMPTY -> .)

    NEURAL_MINUS                   shift and go to state 174
    EMPTY                          shift and go to state 175

state 158

    (75) EXPRESSION_R -> EMPTY .

    GT              reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    LT              reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    OR              reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    AND             reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    COMMA           reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    SEMICOLON       reduce using rule 75 (EXPRESSION_R -> EMPTY .)
    RPAREN          reduce using rule 75 (EXPRESSION_R -> EMPTY .)


state 159

    (78) TERM -> FACTOR NEURAL_TERM TERM_R .

    PLUS            reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    MINUS           reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    GT              reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    LT              reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    OR              reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    AND             reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    COMMA           reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    SEMICOLON       reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)
    RPAREN          reduce using rule 78 (TERM -> FACTOR NEURAL_TERM TERM_R .)


state 160

    (80) TERM_R -> TIMES . NEURAL_TIMES TERM
    (83) NEURAL_TIMES -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    LPAREN          reduce using rule 100 (EMPTY -> .)
    INT             reduce using rule 100 (EMPTY -> .)
    FLOAT           reduce using rule 100 (EMPTY -> .)
    STRING          reduce using rule 100 (EMPTY -> .)

    NEURAL_TIMES                   shift and go to state 176
    EMPTY                          shift and go to state 177

state 161

    (81) TERM_R -> DIVIDE . NEURAL_DIVIDE TERM
    (84) NEURAL_DIVIDE -> . EMPTY
    (100) EMPTY -> .

    ID              reduce using rule 100 (EMPTY -> .)
    LPAREN          reduce using rule 100 (EMPTY -> .)
    INT             reduce using rule 100 (EMPTY -> .)
    FLOAT           reduce using rule 100 (EMPTY -> .)
    STRING          reduce using rule 100 (EMPTY -> .)

    NEURAL_DIVIDE                  shift and go to state 178
    EMPTY                          shift and go to state 179

state 162

    (82) TERM_R -> EMPTY .

    PLUS            reduce using rule 82 (TERM_R -> EMPTY .)
    MINUS           reduce using rule 82 (TERM_R -> EMPTY .)
    GT              reduce using rule 82 (TERM_R -> EMPTY .)
    LT              reduce using rule 82 (TERM_R -> EMPTY .)
    OR              reduce using rule 82 (TERM_R -> EMPTY .)
    AND             reduce using rule 82 (TERM_R -> EMPTY .)
    COMMA           reduce using rule 82 (TERM_R -> EMPTY .)
    SEMICOLON       reduce using rule 82 (TERM_R -> EMPTY .)
    RPAREN          reduce using rule 82 (TERM_R -> EMPTY .)


state 163

    (87) FACTOR -> LPAREN EXPRESSION RPAREN .

    TIMES           reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    DIVIDE          reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    PLUS            reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    MINUS           reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    GT              reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    LT              reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    OR              reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    AND             reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    COMMA           reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    SEMICOLON       reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)
    RPAREN          reduce using rule 87 (FACTOR -> LPAREN EXPRESSION RPAREN .)


state 164

    (43) DECISION -> IF_K LPAREN H_EXPRESSION RPAREN . BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT

    BLOCKSTART      shift and go to state 180


state 165

    (41) WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN . BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKSTART      shift and go to state 181


state 166

    (42) FOR_LOOP -> FOR_K ID EQUALS INT . TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    TO_K            shift and go to state 182


state 167

    (24) PARAM_DECL -> TYPE ID neuro PARAM_DECL_R .

    RPAREN          reduce using rule 24 (PARAM_DECL -> TYPE ID neuro PARAM_DECL_R .)


state 168

    (27) PARAM_DECL_R -> COMMA . PARAM_DECL
    (24) PARAM_DECL -> . TYPE ID neuro PARAM_DECL_R
    (25) PARAM_DECL -> . EMPTY
    (11) TYPE -> . INT_K NEURAL_TYPE
    (12) TYPE -> . FLOAT_K NEURAL_TYPE
    (13) TYPE -> . STRING_K NEURAL_TYPE
    (100) EMPTY -> .

    INT_K           shift and go to state 21
    FLOAT_K         shift and go to state 22
    STRING_K        shift and go to state 23
    RPAREN          reduce using rule 100 (EMPTY -> .)

    PARAM_DECL                     shift and go to state 183
    TYPE                           shift and go to state 68
    EMPTY                          shift and go to state 70

state 169

    (28) PARAM_DECL_R -> EMPTY .

    RPAREN          reduce using rule 28 (PARAM_DECL_R -> EMPTY .)


state 170

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART . PROC_BODY RETURN BLOCKEND PROC_DECL
    (29) PROC_BODY -> . STATEMENT PROC_BODY_R
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    PROC_BODY                      shift and go to state 184
    STATEMENT                      shift and go to state 185
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 171

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART . PROC_BODY BLOCKEND PROC_DECL
    (29) PROC_BODY -> . STATEMENT PROC_BODY_R
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    PROC_BODY                      shift and go to state 186
    STATEMENT                      shift and go to state 185
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 172

    (73) EXPRESSION_R -> PLUS NEURAL_PLUS . EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    EXPRESSION                     shift and go to state 187
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 173

    (76) NEURAL_PLUS -> EMPTY .

    ID              reduce using rule 76 (NEURAL_PLUS -> EMPTY .)
    LPAREN          reduce using rule 76 (NEURAL_PLUS -> EMPTY .)
    INT             reduce using rule 76 (NEURAL_PLUS -> EMPTY .)
    FLOAT           reduce using rule 76 (NEURAL_PLUS -> EMPTY .)
    STRING          reduce using rule 76 (NEURAL_PLUS -> EMPTY .)


state 174

    (74) EXPRESSION_R -> MINUS NEURAL_MINUS . EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    EXPRESSION                     shift and go to state 188
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 175

    (77) NEURAL_MINUS -> EMPTY .

    ID              reduce using rule 77 (NEURAL_MINUS -> EMPTY .)
    LPAREN          reduce using rule 77 (NEURAL_MINUS -> EMPTY .)
    INT             reduce using rule 77 (NEURAL_MINUS -> EMPTY .)
    FLOAT           reduce using rule 77 (NEURAL_MINUS -> EMPTY .)
    STRING          reduce using rule 77 (NEURAL_MINUS -> EMPTY .)


state 176

    (80) TERM_R -> TIMES NEURAL_TIMES . TERM
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    TERM                           shift and go to state 189
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 177

    (83) NEURAL_TIMES -> EMPTY .

    ID              reduce using rule 83 (NEURAL_TIMES -> EMPTY .)
    LPAREN          reduce using rule 83 (NEURAL_TIMES -> EMPTY .)
    INT             reduce using rule 83 (NEURAL_TIMES -> EMPTY .)
    FLOAT           reduce using rule 83 (NEURAL_TIMES -> EMPTY .)
    STRING          reduce using rule 83 (NEURAL_TIMES -> EMPTY .)


state 178

    (81) TERM_R -> DIVIDE NEURAL_DIVIDE . TERM
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    TERM                           shift and go to state 190
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 179

    (84) NEURAL_DIVIDE -> EMPTY .

    ID              reduce using rule 84 (NEURAL_DIVIDE -> EMPTY .)
    LPAREN          reduce using rule 84 (NEURAL_DIVIDE -> EMPTY .)
    INT             reduce using rule 84 (NEURAL_DIVIDE -> EMPTY .)
    FLOAT           reduce using rule 84 (NEURAL_DIVIDE -> EMPTY .)
    STRING          reduce using rule 84 (NEURAL_DIVIDE -> EMPTY .)


state 180

    (43) DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART . STATEMENT_R BLOCKEND DECISION_ALT
    (47) STATEMENT_R -> . STATEMENT STATEMENT_R
    (48) STATEMENT_R -> . EMPTY
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (100) EMPTY -> .
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT_R                    shift and go to state 191
    STATEMENT                      shift and go to state 192
    EMPTY                          shift and go to state 193
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 181

    (41) WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART . STATEMENT_R BLOCKEND
    (47) STATEMENT_R -> . STATEMENT STATEMENT_R
    (48) STATEMENT_R -> . EMPTY
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (100) EMPTY -> .
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT_R                    shift and go to state 194
    STATEMENT                      shift and go to state 192
    EMPTY                          shift and go to state 193
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 182

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K . INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    INT             shift and go to state 195


state 183

    (27) PARAM_DECL_R -> COMMA PARAM_DECL .

    RPAREN          reduce using rule 27 (PARAM_DECL_R -> COMMA PARAM_DECL .)


state 184

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY . RETURN BLOCKEND PROC_DECL
    (70) RETURN -> . RETURN_K LPAREN H_EXPRESSION RPAREN SEMICOLON

    RETURN_K        shift and go to state 197

    RETURN                         shift and go to state 196

state 185

    (29) PROC_BODY -> STATEMENT . PROC_BODY_R
    (30) PROC_BODY_R -> . PROC_BODY
    (31) PROC_BODY_R -> . EMPTY
    (29) PROC_BODY -> . STATEMENT PROC_BODY_R
    (100) EMPTY -> .
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    RETURN_K        reduce using rule 100 (EMPTY -> .)
    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT                      shift and go to state 185
    PROC_BODY_R                    shift and go to state 198
    PROC_BODY                      shift and go to state 199
    EMPTY                          shift and go to state 200
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 186

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY . BLOCKEND PROC_DECL

    BLOCKEND        shift and go to state 201


state 187

    (73) EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .

    GT              reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    LT              reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    OR              reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    AND             reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    COMMA           reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    SEMICOLON       reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)
    RPAREN          reduce using rule 73 (EXPRESSION_R -> PLUS NEURAL_PLUS EXPRESSION .)


state 188

    (74) EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .

    GT              reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    LT              reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    OR              reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    AND             reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    COMMA           reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    SEMICOLON       reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)
    RPAREN          reduce using rule 74 (EXPRESSION_R -> MINUS NEURAL_MINUS EXPRESSION .)


state 189

    (80) TERM_R -> TIMES NEURAL_TIMES TERM .

    PLUS            reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    MINUS           reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    GT              reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    LT              reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    OR              reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    AND             reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    COMMA           reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    SEMICOLON       reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)
    RPAREN          reduce using rule 80 (TERM_R -> TIMES NEURAL_TIMES TERM .)


state 190

    (81) TERM_R -> DIVIDE NEURAL_DIVIDE TERM .

    PLUS            reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    MINUS           reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    GT              reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    LT              reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    OR              reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    AND             reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    COMMA           reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    SEMICOLON       reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)
    RPAREN          reduce using rule 81 (TERM_R -> DIVIDE NEURAL_DIVIDE TERM .)


state 191

    (43) DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R . BLOCKEND DECISION_ALT

    BLOCKEND        shift and go to state 202


state 192

    (47) STATEMENT_R -> STATEMENT . STATEMENT_R
    (47) STATEMENT_R -> . STATEMENT STATEMENT_R
    (48) STATEMENT_R -> . EMPTY
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (100) EMPTY -> .
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT                      shift and go to state 192
    STATEMENT_R                    shift and go to state 203
    EMPTY                          shift and go to state 193
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 193

    (48) STATEMENT_R -> EMPTY .

    BLOCKEND        reduce using rule 48 (STATEMENT_R -> EMPTY .)


state 194

    (41) WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R . BLOCKEND

    BLOCKEND        shift and go to state 204


state 195

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT . DO_K BLOCKSTART STATEMENT_R BLOCKEND

    DO_K            shift and go to state 205


state 196

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN . BLOCKEND PROC_DECL

    BLOCKEND        shift and go to state 206


state 197

    (70) RETURN -> RETURN_K . LPAREN H_EXPRESSION RPAREN SEMICOLON

    LPAREN          shift and go to state 207


state 198

    (29) PROC_BODY -> STATEMENT PROC_BODY_R .

    RETURN_K        reduce using rule 29 (PROC_BODY -> STATEMENT PROC_BODY_R .)
    BLOCKEND        reduce using rule 29 (PROC_BODY -> STATEMENT PROC_BODY_R .)


state 199

    (30) PROC_BODY_R -> PROC_BODY .

    RETURN_K        reduce using rule 30 (PROC_BODY_R -> PROC_BODY .)
    BLOCKEND        reduce using rule 30 (PROC_BODY_R -> PROC_BODY .)


state 200

    (31) PROC_BODY_R -> EMPTY .

    RETURN_K        reduce using rule 31 (PROC_BODY_R -> EMPTY .)
    BLOCKEND        reduce using rule 31 (PROC_BODY_R -> EMPTY .)


state 201

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND . PROC_DECL
    (16) PROC_DECL -> . PROC_DECL_RETURN
    (17) PROC_DECL -> . PROC_DECL_VOID
    (18) PROC_DECL -> . EMPTY
    (21) PROC_DECL_RETURN -> . FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (19) PROC_DECL_VOID -> . FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (100) EMPTY -> .

    FUNCTION_K      shift and go to state 15
    MAIN_K          reduce using rule 100 (EMPTY -> .)

    PROC_DECL                      shift and go to state 208
    PROC_DECL_RETURN               shift and go to state 12
    PROC_DECL_VOID                 shift and go to state 13
    EMPTY                          shift and go to state 14

state 202

    (43) DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND . DECISION_ALT
    (44) DECISION_ALT -> . ELSE_K DECISION
    (45) DECISION_ALT -> . BLOCKSTART STATEMENT_R BLOCKEND
    (46) DECISION_ALT -> . EMPTY
    (100) EMPTY -> .

    ELSE_K          shift and go to state 211
    BLOCKSTART      shift and go to state 209
    ID              reduce using rule 100 (EMPTY -> .)
    READ_K          reduce using rule 100 (EMPTY -> .)
    WRITE_K         reduce using rule 100 (EMPTY -> .)
    IF_K            reduce using rule 100 (EMPTY -> .)
    WHILE_K         reduce using rule 100 (EMPTY -> .)
    FOR_K           reduce using rule 100 (EMPTY -> .)
    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    RETURN_K        reduce using rule 100 (EMPTY -> .)

    DECISION_ALT                   shift and go to state 210
    EMPTY                          shift and go to state 212

state 203

    (47) STATEMENT_R -> STATEMENT STATEMENT_R .

    BLOCKEND        reduce using rule 47 (STATEMENT_R -> STATEMENT STATEMENT_R .)


state 204

    (41) WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .

    ID              reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    READ_K          reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    WRITE_K         reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    IF_K            reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    WHILE_K         reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    FOR_K           reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    BLOCKEND        reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)
    RETURN_K        reduce using rule 41 (WHILE_LOOP -> WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND .)


state 205

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K . BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKSTART      shift and go to state 213


state 206

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND . PROC_DECL
    (16) PROC_DECL -> . PROC_DECL_RETURN
    (17) PROC_DECL -> . PROC_DECL_VOID
    (18) PROC_DECL -> . EMPTY
    (21) PROC_DECL_RETURN -> . FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL
    (19) PROC_DECL_VOID -> . FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL
    (100) EMPTY -> .

    FUNCTION_K      shift and go to state 15
    MAIN_K          reduce using rule 100 (EMPTY -> .)

    PROC_DECL                      shift and go to state 214
    PROC_DECL_RETURN               shift and go to state 12
    PROC_DECL_VOID                 shift and go to state 13
    EMPTY                          shift and go to state 14

state 207

    (70) RETURN -> RETURN_K LPAREN . H_EXPRESSION RPAREN SEMICOLON
    (92) H_EXPRESSION -> . S_EXPRESSION H_EXPRESSION_R
    (89) S_EXPRESSION -> . EXPRESSION
    (90) S_EXPRESSION -> . EXPRESSION GT EXPRESSION
    (91) S_EXPRESSION -> . EXPRESSION LT EXPRESSION
    (71) EXPRESSION -> . TERM NEURAL_EXPRESSION EXPRESSION_R
    (78) TERM -> . FACTOR NEURAL_TERM TERM_R
    (85) FACTOR -> . ID NEURAL_ID
    (86) FACTOR -> . CONSTANT
    (87) FACTOR -> . LPAREN EXPRESSION RPAREN
    (59) CONSTANT -> . INT
    (60) CONSTANT -> . FLOAT
    (61) CONSTANT -> . STRING

    ID              shift and go to state 95
    LPAREN          shift and go to state 97
    INT             shift and go to state 98
    FLOAT           shift and go to state 99
    STRING          shift and go to state 100

    H_EXPRESSION                   shift and go to state 215
    S_EXPRESSION                   shift and go to state 91
    EXPRESSION                     shift and go to state 92
    TERM                           shift and go to state 93
    FACTOR                         shift and go to state 94
    CONSTANT                       shift and go to state 96

state 208

    (19) PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL .

    MAIN_K          reduce using rule 19 (PROC_DECL_VOID -> FUNCTION_K VOID_K ID neural_proc_void_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY BLOCKEND PROC_DECL .)


state 209

    (45) DECISION_ALT -> BLOCKSTART . STATEMENT_R BLOCKEND
    (47) STATEMENT_R -> . STATEMENT STATEMENT_R
    (48) STATEMENT_R -> . EMPTY
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (100) EMPTY -> .
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT_R                    shift and go to state 216
    STATEMENT                      shift and go to state 192
    EMPTY                          shift and go to state 193
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 210

    (43) DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .

    ID              reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    READ_K          reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    WRITE_K         reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    IF_K            reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    WHILE_K         reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    FOR_K           reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    BLOCKEND        reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)
    RETURN_K        reduce using rule 43 (DECISION -> IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT .)


state 211

    (44) DECISION_ALT -> ELSE_K . DECISION
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT

    IF_K            shift and go to state 63

    DECISION                       shift and go to state 217

state 212

    (46) DECISION_ALT -> EMPTY .

    ID              reduce using rule 46 (DECISION_ALT -> EMPTY .)
    READ_K          reduce using rule 46 (DECISION_ALT -> EMPTY .)
    WRITE_K         reduce using rule 46 (DECISION_ALT -> EMPTY .)
    IF_K            reduce using rule 46 (DECISION_ALT -> EMPTY .)
    WHILE_K         reduce using rule 46 (DECISION_ALT -> EMPTY .)
    FOR_K           reduce using rule 46 (DECISION_ALT -> EMPTY .)
    BLOCKEND        reduce using rule 46 (DECISION_ALT -> EMPTY .)
    RETURN_K        reduce using rule 46 (DECISION_ALT -> EMPTY .)


state 213

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART . STATEMENT_R BLOCKEND
    (47) STATEMENT_R -> . STATEMENT STATEMENT_R
    (48) STATEMENT_R -> . EMPTY
    (32) STATEMENT -> . ASSIGN SEMICOLON
    (33) STATEMENT -> . FUNC_CALL SEMICOLON
    (34) STATEMENT -> . READ SEMICOLON
    (35) STATEMENT -> . WRITE SEMICOLON
    (36) STATEMENT -> . FLOW
    (100) EMPTY -> .
    (49) ASSIGN -> . VAR EQUALS H_EXPRESSION
    (53) FUNC_CALL -> . ID LPAREN ARG_LIST RPAREN
    (62) READ -> . READ_K ID_LIST
    (66) WRITE -> . WRITE_K WRITE_LIST
    (37) FLOW -> . DECISION
    (38) FLOW -> . LOOP
    (50) VAR -> . ID
    (51) VAR -> . ARRAY
    (43) DECISION -> . IF_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND DECISION_ALT
    (39) LOOP -> . WHILE_LOOP
    (40) LOOP -> . FOR_LOOP
    (52) ARRAY -> . ID LBRACE INT RBRACE
    (41) WHILE_LOOP -> . WHILE_K LPAREN H_EXPRESSION RPAREN BLOCKSTART STATEMENT_R BLOCKEND
    (42) FOR_LOOP -> . FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND

    BLOCKEND        reduce using rule 100 (EMPTY -> .)
    ID              shift and go to state 57
    READ_K          shift and go to state 58
    WRITE_K         shift and go to state 59
    IF_K            shift and go to state 63
    WHILE_K         shift and go to state 66
    FOR_K           shift and go to state 67

    STATEMENT_R                    shift and go to state 218
    STATEMENT                      shift and go to state 192
    EMPTY                          shift and go to state 193
    ASSIGN                         shift and go to state 51
    FUNC_CALL                      shift and go to state 52
    READ                           shift and go to state 53
    WRITE                          shift and go to state 54
    FLOW                           shift and go to state 55
    VAR                            shift and go to state 56
    DECISION                       shift and go to state 60
    LOOP                           shift and go to state 61
    ARRAY                          shift and go to state 62
    WHILE_LOOP                     shift and go to state 64
    FOR_LOOP                       shift and go to state 65

state 214

    (21) PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL .

    MAIN_K          reduce using rule 21 (PROC_DECL_RETURN -> FUNCTION_K TYPE ID neural_proc_return_id LPAREN PARAM_DECL RPAREN neural_param_decl BLOCKSTART PROC_BODY RETURN BLOCKEND PROC_DECL .)


state 215

    (70) RETURN -> RETURN_K LPAREN H_EXPRESSION . RPAREN SEMICOLON

    RPAREN          shift and go to state 219


state 216

    (45) DECISION_ALT -> BLOCKSTART STATEMENT_R . BLOCKEND

    BLOCKEND        shift and go to state 220


state 217

    (44) DECISION_ALT -> ELSE_K DECISION .

    ID              reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    READ_K          reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    WRITE_K         reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    IF_K            reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    WHILE_K         reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    FOR_K           reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    BLOCKEND        reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)
    RETURN_K        reduce using rule 44 (DECISION_ALT -> ELSE_K DECISION .)


state 218

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R . BLOCKEND

    BLOCKEND        shift and go to state 221


state 219

    (70) RETURN -> RETURN_K LPAREN H_EXPRESSION RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 222


state 220

    (45) DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .

    ID              reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    READ_K          reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    WRITE_K         reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    IF_K            reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    WHILE_K         reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    FOR_K           reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    BLOCKEND        reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)
    RETURN_K        reduce using rule 45 (DECISION_ALT -> BLOCKSTART STATEMENT_R BLOCKEND .)


state 221

    (42) FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .

    ID              reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    READ_K          reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    WRITE_K         reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    IF_K            reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    WHILE_K         reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    FOR_K           reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    BLOCKEND        reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)
    RETURN_K        reduce using rule 42 (FOR_LOOP -> FOR_K ID EQUALS INT TO_K INT DO_K BLOCKSTART STATEMENT_R BLOCKEND .)


state 222

    (70) RETURN -> RETURN_K LPAREN H_EXPRESSION RPAREN SEMICOLON .

    BLOCKEND        reduce using rule 70 (RETURN -> RETURN_K LPAREN H_EXPRESSION RPAREN SEMICOLON .)

